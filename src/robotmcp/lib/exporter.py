"""Test suite generation from recorded executions.

Exports recorded keyword executions as:
- Robot Framework .robot files
- JSON format for programmatic access
- YAML format for human-readable configuration
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

import yaml

from robotmcp.lib.recorder import ExecutionRecorder, RecordedStep, StepType, get_recorder

logger = logging.getLogger(__name__)


class TestSuiteExporter:
    """Exports recorded executions as Robot Framework test suites."""

    def __init__(self, recorder: ExecutionRecorder = None):
        """Initialize the exporter.

        Args:
            recorder: ExecutionRecorder to export from. Uses global if None.
        """
        self.recorder = recorder or get_recorder()

    def export(
        self,
        path: str,
        suite_name: str = "Generated Suite",
        test_name: str = "Generated Test",
        include_comments: bool = True,
        include_imports: bool = True,
        format: str = "robot",
        group_by_prompt: bool = True,
        exclude_libraries: List[str] = None,
        exclude_keywords: List[str] = None,
        flatten_ai_only: bool = True,
        include_setup_teardown: bool = True,
    ) -> str:
        """Export recorded steps to a file.

        Args:
            path: Output file path
            suite_name: Name for the test suite
            test_name: Name for the test case
            include_comments: Include AI prompts as comments
            include_imports: Auto-detect and include Library imports
            format: Output format ('robot', 'json', 'yaml')
            group_by_prompt: Group keywords under original AI prompt
            exclude_libraries: Libraries to exclude from export
            exclude_keywords: Keywords to exclude from export
            flatten_ai_only: Expand AI keywords into sub-keywords
            include_setup_teardown: Include [Setup]/[Teardown] sections

        Returns:
            Path to the exported file
        """
        format = format.lower()

        if format == "robot":
            content = self._generate_robot_file(
                suite_name=suite_name,
                test_name=test_name,
                include_comments=include_comments,
                include_imports=include_imports,
                group_by_prompt=group_by_prompt,
                exclude_libraries=set(exclude_libraries or []),
                exclude_keywords=set(kw.lower() for kw in (exclude_keywords or [])),
                flatten_ai_only=flatten_ai_only,
                include_setup_teardown=include_setup_teardown,
            )
        elif format == "json":
            content = self._generate_json(
                suite_name=suite_name,
                test_name=test_name,
                exclude_libraries=set(exclude_libraries or []),
                exclude_keywords=set(kw.lower() for kw in (exclude_keywords or [])),
            )
        elif format == "yaml":
            content = self._generate_yaml(
                suite_name=suite_name,
                test_name=test_name,
                exclude_libraries=set(exclude_libraries or []),
                exclude_keywords=set(kw.lower() for kw in (exclude_keywords or [])),
            )
        else:
            raise ValueError(f"Unsupported format: {format}. Use 'robot', 'json', or 'yaml'.")

        # Write to file
        output_path = Path(path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)

        logger.info(f"Exported test suite to: {output_path}")
        return str(output_path)

    def _generate_robot_file(
        self,
        suite_name: str,
        test_name: str,
        include_comments: bool,
        include_imports: bool,
        group_by_prompt: bool,
        exclude_libraries: Set[str],
        exclude_keywords: Set[str],
        flatten_ai_only: bool,
        include_setup_teardown: bool,
    ) -> str:
        """Generate Robot Framework .robot file content.

        Returns:
            Robot Framework test file content
        """
        lines = []
        metadata = self.recorder.get_metadata()

        # Header comment
        lines.append("# Auto-generated by AILibrary from rf-mcp")
        if metadata.get("started_at"):
            lines.append(f"# Generated: {metadata['started_at']}")
        lines.append("")

        # Settings section
        lines.append("*** Settings ***")
        if include_imports:
            libraries = self._get_required_libraries(exclude_libraries)
            for lib in libraries:
                lines.append(f"Library    {lib}")
        lines.append("")

        # Test Cases section
        lines.append("*** Test Cases ***")
        lines.append(test_name)
        lines.append("    [Documentation]    Generated from AI-driven test execution")

        # Get steps
        steps = self.recorder.get_steps()
        setup_steps = []
        teardown_steps = []
        regular_steps = []

        for step in steps:
            if step.keyword.lower() in exclude_keywords:
                continue
            if step.library and step.library in exclude_libraries:
                continue

            if step.step_type == StepType.SETUP:
                setup_steps.append(step)
            elif step.step_type == StepType.TEARDOWN:
                teardown_steps.append(step)
            else:
                regular_steps.append(step)

        # Add setup if present
        if include_setup_teardown and setup_steps:
            lines.append("    [Setup]    Run Keywords")
            for step in setup_steps:
                keyword_line = self._format_keyword_call(step)
                lines.append(f"    ...    {keyword_line}")

        # Add regular steps
        for step in regular_steps:
            step_lines = self._format_step(
                step,
                include_comments=include_comments,
                group_by_prompt=group_by_prompt,
                flatten_ai=flatten_ai_only,
            )
            for line in step_lines:
                lines.append(f"    {line}")

        # Add teardown if present
        if include_setup_teardown and teardown_steps:
            lines.append("    [Teardown]    Run Keywords")
            for step in teardown_steps:
                keyword_line = self._format_keyword_call(step)
                lines.append(f"    ...    {keyword_line}")

        lines.append("")
        return "\n".join(lines)

    def _format_step(
        self,
        step: RecordedStep,
        include_comments: bool,
        group_by_prompt: bool,
        flatten_ai: bool,
    ) -> List[str]:
        """Format a recorded step as Robot Framework lines.

        Args:
            step: RecordedStep to format
            include_comments: Include comments for AI steps
            group_by_prompt: Group AI sub-keywords under prompt comment
            flatten_ai: Expand AI keywords into sub-keywords

        Returns:
            List of formatted lines
        """
        lines = []

        if step.step_type == StepType.AI:
            # AI keyword step
            if include_comments and step.prompt:
                lines.append(f"# AI: {step.ai_keyword}    {step.prompt}")

            if flatten_ai and step.executed_keywords:
                # Expand into individual keywords
                # For Ask keywords with variable assignment, apply it to the last keyword
                # (since that's the one that returns the value)
                sub_steps = step.executed_keywords
                for i, sub_step in enumerate(sub_steps):
                    is_last = (i == len(sub_steps) - 1)
                    # Apply variable assignment to last keyword for Ask
                    if is_last and step.assigned_variable and step.ai_keyword == "Ask":
                        keyword_line = self._format_keyword_call(
                            sub_step, assigned_variable=step.assigned_variable
                        )
                    else:
                        keyword_line = self._format_keyword_call(sub_step)
                    lines.append(keyword_line)
            else:
                # Keep as AI keyword
                keyword_line = self._format_keyword_call(step)
                lines.append(keyword_line)
        else:
            # Regular keyword
            keyword_line = self._format_keyword_call(step)
            lines.append(keyword_line)

        return lines

    def _format_keyword_call(
        self, step: RecordedStep, assigned_variable: str = None
    ) -> str:
        """Format a single keyword call.

        Args:
            step: RecordedStep to format
            assigned_variable: Optional override for variable assignment
                (used when flattening AI keywords)

        Returns:
            Formatted keyword call string
        """
        parts = []

        # Use provided assigned_variable or fall back to step's own
        var_to_assign = assigned_variable or step.assigned_variable

        # Add variable assignment if present (for Ask keyword results)
        if var_to_assign:
            var_name = var_to_assign
            # Ensure proper ${} syntax
            if not var_name.startswith("${"):
                var_name = f"${{{var_name}}}"
            parts.append(f"{var_name}=")

        parts.append(step.keyword)

        # Add positional arguments
        for arg in step.args:
            formatted_arg = self._format_argument(arg)
            parts.append(formatted_arg)

        # Add named arguments
        for key, value in step.kwargs.items():
            formatted_value = self._format_argument(value)
            parts.append(f"{key}={formatted_value}")

        return "    ".join(parts)

    def _format_argument(self, arg: Any) -> str:
        """Format an argument value for Robot Framework.

        Args:
            arg: Argument value

        Returns:
            Formatted argument string
        """
        if arg is None:
            return "${NONE}"
        elif arg is True:
            return "${TRUE}"
        elif arg is False:
            return "${FALSE}"
        elif isinstance(arg, (int, float)):
            return str(arg)
        elif isinstance(arg, str):
            # Escape special characters if needed
            if "    " in arg or arg.startswith("#"):
                return f"'{arg}'"
            return arg
        elif isinstance(arg, list):
            return "@{" + ", ".join(self._format_argument(a) for a in arg) + "}"
        elif isinstance(arg, dict):
            return "&{" + ", ".join(f"{k}={self._format_argument(v)}" for k, v in arg.items()) + "}"
        else:
            return str(arg)

    def _get_required_libraries(self, exclude: Set[str]) -> List[str]:
        """Get list of libraries required for the recording.

        Args:
            exclude: Libraries to exclude

        Returns:
            List of library names to import
        """
        libraries = set()

        for step in self.recorder.get_steps():
            if step.library and step.library not in exclude:
                libraries.add(step.library)

            # Also check sub-steps for AI keywords
            if step.step_type == StepType.AI:
                for sub_step in step.executed_keywords:
                    if sub_step.library and sub_step.library not in exclude:
                        libraries.add(sub_step.library)

        # Remove BuiltIn as it's always available
        libraries.discard("BuiltIn")

        return sorted(libraries)

    def _generate_json(
        self,
        suite_name: str,
        test_name: str,
        exclude_libraries: Set[str],
        exclude_keywords: Set[str],
    ) -> str:
        """Generate JSON format output.

        Returns:
            JSON string
        """
        metadata = self.recorder.get_metadata()
        steps = self.recorder.get_steps()

        # Filter steps
        filtered_steps = []
        for step in steps:
            if step.keyword.lower() in exclude_keywords:
                continue
            if step.library and step.library in exclude_libraries:
                continue
            filtered_steps.append(self._step_to_json_dict(step))

        data = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "suite_name": suite_name,
                "test_name": test_name,
                "source_metadata": metadata,
            },
            "required_libraries": self._get_required_libraries(exclude_libraries),
            "steps": filtered_steps,
        }

        return json.dumps(data, indent=2, default=str)

    def _step_to_json_dict(self, step: RecordedStep) -> Dict[str, Any]:
        """Convert a step to JSON-serializable dictionary.

        Args:
            step: RecordedStep to convert

        Returns:
            Dictionary representation
        """
        data = {
            "type": step.step_type.value,
            "keyword": step.keyword,
            "args": step.args,
            "library": step.library,
        }

        if step.kwargs:
            data["kwargs"] = step.kwargs

        # Include variable assignment if present
        if step.assigned_variable:
            data["assigned_variable"] = step.assigned_variable

        if step.step_type == StepType.AI:
            data["prompt"] = step.prompt
            data["ai_keyword"] = step.ai_keyword
            data["expanded_keywords"] = [
                self._step_to_json_dict(sub) for sub in step.executed_keywords
            ]
            data["attempts"] = step.attempts

        return data

    def _generate_yaml(
        self,
        suite_name: str,
        test_name: str,
        exclude_libraries: Set[str],
        exclude_keywords: Set[str],
    ) -> str:
        """Generate YAML format output.

        Returns:
            YAML string
        """
        # Use JSON generation and convert
        json_str = self._generate_json(suite_name, test_name, exclude_libraries, exclude_keywords)
        data = json.loads(json_str)
        return yaml.dump(data, default_flow_style=False, sort_keys=False)


def export_recording(
    path: str,
    suite_name: str = "Generated Suite",
    test_name: str = "Generated Test",
    format: str = "robot",
    **kwargs,
) -> str:
    """Convenience function to export the global recording.

    Args:
        path: Output file path
        suite_name: Name for the test suite
        test_name: Name for the test case
        format: Output format ('robot', 'json', 'yaml')
        **kwargs: Additional export options

    Returns:
        Path to the exported file
    """
    exporter = TestSuiteExporter()
    return exporter.export(
        path=path,
        suite_name=suite_name,
        test_name=test_name,
        format=format,
        **kwargs,
    )
