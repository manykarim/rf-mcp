"""Tests for exporter module."""

import json
import os
import tempfile

import pytest
import yaml

from robotmcp.lib.exporter import TestSuiteExporter
from robotmcp.lib.recorder import ExecutionRecorder, RecordedStep, StepType


class TestTestSuiteExporter:
    """Tests for TestSuiteExporter class."""

    def setup_method(self):
        """Set up test recorder with sample steps."""
        self.recorder = ExecutionRecorder()
        self.recorder.start_recording()

        # Add regular steps
        self.recorder.record_step(
            keyword="New Browser",
            args=["chromium"],
            kwargs={"headless": "false"},
            library="Browser",
        )
        self.recorder.record_step(
            keyword="New Page",
            args=["https://example.com"],
            library="Browser",
        )

        # Add AI step with sub-steps
        ai_step = self.recorder.start_ai_step(
            prompt="Login as user1 with password secret",
            ai_keyword="Do",
        )
        self.recorder.record_step(
            keyword="Fill Text",
            args=["id=username", "user1"],
            library="Browser",
        )
        self.recorder.record_step(
            keyword="Fill Text",
            args=["id=password", "secret"],
            library="Browser",
        )
        self.recorder.record_step(
            keyword="Click",
            args=["id=login-button"],
            library="Browser",
        )
        self.recorder.end_ai_step(success=True, attempts=1)

        self.recorder.stop_recording()
        self.exporter = TestSuiteExporter(self.recorder)

    def test_export_robot_format(self):
        """Test exporting to .robot format."""
        # Create temp file and close it before use (Windows compatibility)
        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                suite_name="Test Suite",
                test_name="Test Case",
                format="robot",
            )

            with open(path) as f:
                content = f.read()

            # Check header
            assert "Auto-generated by AILibrary" in content

            # Check settings
            assert "*** Settings ***" in content
            assert "Library    Browser" in content

            # Check test case
            assert "*** Test Cases ***" in content
            assert "Test Case" in content

            # Check keywords
            assert "New Browser" in content
            assert "New Page" in content
            assert "Fill Text" in content
            assert "Click" in content
        finally:
            os.unlink(temp_path)

    def test_export_with_comments(self):
        """Test that AI prompts are included as comments."""
        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                format="robot",
                include_comments=True,
            )

            with open(path) as f:
                content = f.read()

            # Check AI prompt comment
            assert "# AI: Do" in content
            assert "Login as user1" in content
        finally:
            os.unlink(temp_path)

    def test_export_without_comments(self):
        """Test export without AI prompt comments."""
        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                format="robot",
                include_comments=False,
            )

            with open(path) as f:
                content = f.read()

            # Should not have AI comments
            assert "# AI:" not in content
        finally:
            os.unlink(temp_path)

    def test_export_json_format(self):
        """Test exporting to JSON format."""
        fd, temp_path = tempfile.mkstemp(suffix=".json")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                suite_name="Test Suite",
                test_name="Test Case",
                format="json",
            )

            with open(path) as f:
                data = json.load(f)

            # Check metadata
            assert "metadata" in data
            assert data["metadata"]["suite_name"] == "Test Suite"
            assert data["metadata"]["test_name"] == "Test Case"

            # Check required libraries
            assert "required_libraries" in data
            assert "Browser" in data["required_libraries"]

            # Check steps
            assert "steps" in data
            assert len(data["steps"]) > 0
        finally:
            os.unlink(temp_path)

    def test_export_yaml_format(self):
        """Test exporting to YAML format."""
        fd, temp_path = tempfile.mkstemp(suffix=".yaml")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                format="yaml",
            )

            with open(path) as f:
                data = yaml.safe_load(f)

            assert "metadata" in data
            assert "steps" in data
        finally:
            os.unlink(temp_path)

    def test_export_exclude_libraries(self):
        """Test excluding libraries from export."""
        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                format="robot",
                exclude_libraries=["BuiltIn"],
            )

            with open(path) as f:
                content = f.read()

            # BuiltIn should not be imported (it's always available anyway)
            # But Browser should still be there
            assert "Library    Browser" in content
        finally:
            os.unlink(temp_path)

    def test_export_exclude_keywords(self):
        """Test excluding keywords from export."""
        self.recorder.start_recording()
        self.recorder.record_step(keyword="Log", args=["Debug message"], library="BuiltIn")
        self.recorder.stop_recording()

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = self.exporter.export(
                path=temp_path,
                format="robot",
                exclude_keywords=["Log"],
            )

            with open(path) as f:
                content = f.read()

            # Log keyword should be excluded
            # But other keywords should still be there
            lines = content.split("\n")
            log_lines = [l for l in lines if l.strip().startswith("Log")]
            # There shouldn't be standalone Log keyword lines
            assert len([l for l in log_lines if "Log" == l.strip().split()[0]]) == 0
        finally:
            os.unlink(temp_path)

    def test_format_argument_special_values(self):
        """Test formatting special argument values."""
        # Test None, True, False
        assert self.exporter._format_argument(None) == "${NONE}"
        assert self.exporter._format_argument(True) == "${TRUE}"
        assert self.exporter._format_argument(False) == "${FALSE}"

        # Test numbers
        assert self.exporter._format_argument(42) == "42"
        assert self.exporter._format_argument(3.14) == "3.14"

        # Test strings
        assert self.exporter._format_argument("hello") == "hello"
        assert self.exporter._format_argument("#special") == "'#special'"

    def test_get_required_libraries(self):
        """Test detecting required libraries."""
        libs = self.exporter._get_required_libraries(exclude=set())

        assert "Browser" in libs
        # BuiltIn should be excluded
        assert "BuiltIn" not in libs

    def test_invalid_format_raises_error(self):
        """Test that invalid format raises ValueError."""
        fd, temp_path = tempfile.mkstemp()
        os.close(fd)

        try:
            with pytest.raises(ValueError) as exc_info:
                self.exporter.export(
                    path=temp_path,
                    format="invalid",
                )

            assert "Unsupported format" in str(exc_info.value)
        finally:
            os.unlink(temp_path)

    def test_creates_parent_directories(self):
        """Test that export creates parent directories."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = os.path.join(tmpdir, "subdir", "nested", "test.robot")

            result_path = self.exporter.export(
                path=path,
                format="robot",
            )

            assert os.path.exists(result_path)
            assert os.path.isfile(result_path)

    def test_export_with_variable_assignment(self):
        """Test that Ask keyword with assigned_variable exports with ${var}= syntax."""
        # Create a fresh recorder with an Ask step that has assigned_variable
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # Add an Ask step with variable assignment
        ai_step = recorder.start_ai_step(
            prompt="What is the name of the first product?",
            ai_keyword="Ask",
            assigned_variable="product_name",
        )
        recorder.record_step(
            keyword="Get Text",
            args=[".inventory_item_name >> nth=0"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="Sauce Labs Backpack", attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                suite_name="Variable Assignment Test",
                test_name="Test Ask With Variable",
                format="robot",
                flatten_ai_only=False,  # Keep AI keyword, don't flatten to sub-keywords
            )

            with open(path) as f:
                content = f.read()

            # Check that the variable assignment syntax is included
            assert "${product_name}=" in content
            assert "Ask" in content
            assert "What is the name of the first product?" in content
        finally:
            os.unlink(temp_path)

    def test_export_variable_assignment_json(self):
        """Test that assigned_variable is included in JSON export."""
        # Create a fresh recorder with an Ask step that has assigned_variable
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # Add an Ask step with variable assignment
        recorder.start_ai_step(
            prompt="What is the price?",
            ai_keyword="Ask",
            assigned_variable="price",
        )
        recorder.record_step(
            keyword="Get Text",
            args=[".inventory_item_price"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="$29.99", attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".json")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                format="json",
            )

            with open(path) as f:
                data = json.load(f)

            # Check that assigned_variable is in the step data
            ai_steps = [s for s in data["steps"] if s["type"] == "ai"]
            assert len(ai_steps) == 1
            assert ai_steps[0]["assigned_variable"] == "price"
        finally:
            os.unlink(temp_path)

    def test_export_variable_assignment_with_dollar_braces(self):
        """Test that variable names with ${} are normalized properly."""
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # Add an Ask step with variable assignment using ${} syntax
        recorder.start_ai_step(
            prompt="What is the order ID?",
            ai_keyword="Ask",
            assigned_variable="${order_id}",  # With ${} syntax
        )
        recorder.record_step(
            keyword="Get Text",
            args=["[data-test='order-id']"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="12345", attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                format="robot",
                flatten_ai_only=False,
            )

            with open(path) as f:
                content = f.read()

            # Should have proper ${var}= syntax without double ${${}}
            assert "${order_id}=" in content
            # Should NOT have ${${order_id}}=
            assert "${${order_id}}" not in content
        finally:
            os.unlink(temp_path)

    def test_export_flattened_ask_with_variable_assignment(self):
        """Test that flattened Ask keywords apply variable assignment to last sub-keyword."""
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # Add an Ask step with variable assignment and sub-keywords
        recorder.start_ai_step(
            prompt="What is the name of the first product?",
            ai_keyword="Ask",
            assigned_variable="product_name",
        )
        # Simulate the AI executing Get Text
        recorder.record_step(
            keyword="Get Text",
            args=[".inventory_item_name >> nth=0"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="Sauce Labs Backpack", attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                format="robot",
                flatten_ai_only=True,  # Flatten AI keywords into sub-keywords
            )

            with open(path) as f:
                content = f.read()

            # The flattened Get Text should have the variable assignment
            assert "${product_name}=" in content
            assert "Get Text" in content
            assert ".inventory_item_name >> nth=0" in content
        finally:
            os.unlink(temp_path)

    def test_export_multiple_ask_keywords_with_variables(self):
        """Test multiple Ask keywords each with their own variable assignments."""
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # First Ask
        recorder.start_ai_step(
            prompt="What is the name of the first product?",
            ai_keyword="Ask",
            assigned_variable="product_name",
        )
        recorder.record_step(
            keyword="Get Text",
            args=[".inventory_item_name >> nth=0"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="Sauce Labs Backpack", attempts=1)

        # Second Ask
        recorder.start_ai_step(
            prompt="What is the price of the first product?",
            ai_keyword="Ask",
            assigned_variable="product_price",
        )
        recorder.record_step(
            keyword="Get Text",
            args=[".inventory_item_price >> nth=0"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, result="$29.99", attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                format="robot",
                flatten_ai_only=True,
            )

            with open(path) as f:
                content = f.read()

            # Both variable assignments should be present
            assert "${product_name}=" in content
            assert "${product_price}=" in content
            assert ".inventory_item_name >> nth=0" in content
            assert ".inventory_item_price >> nth=0" in content
        finally:
            os.unlink(temp_path)

    def test_export_do_keyword_no_variable_assignment(self):
        """Test that Do keywords don't get variable assignment (since they return None)."""
        recorder = ExecutionRecorder()
        recorder.start_recording()

        # Do step (no variable assignment expected)
        recorder.start_ai_step(
            prompt="Click the login button",
            ai_keyword="Do",
        )
        recorder.record_step(
            keyword="Click",
            args=["[data-test='login-button']"],
            library="Browser",
        )
        recorder.end_ai_step(success=True, attempts=1)

        recorder.stop_recording()

        exporter = TestSuiteExporter(recorder)

        fd, temp_path = tempfile.mkstemp(suffix=".robot")
        os.close(fd)

        try:
            path = exporter.export(
                path=temp_path,
                format="robot",
                flatten_ai_only=True,
            )

            with open(path) as f:
                content = f.read()

            # Should NOT have variable assignment for Do keyword
            assert "${" not in content.split("Click")[0]  # No var before Click
            assert "Click    [data-test='login-button']" in content
        finally:
            os.unlink(temp_path)
